{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-dc296706-ea33-441f-9152-34764edb4da2",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, and other security issues. The `sprintf` function is one such function that is often flagged because it does not perform bounds checking on the destination buffer, which can lead to buffer overflow if the input data exceeds the buffer size.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives that perform bounds checking. In C++, you can use `snprintf` or `std::stringstream` to safely format strings. These alternatives help prevent buffer overflows by ensuring that the destination buffer is not overrun.\n\n### Source Code Fix Recommendation\n\nReplace the use of `sprintf` with `snprintf` to ensure that the buffer size is respected. Here is a fixed version of the code:\n\n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst size_t BUFFER_SIZE = 1024; // Define an appropriate buffer size\n\nvoid safeFunction(const char* pdi_dir, const char* filenames[], size_t i) {\n    char full_name[BUFFER_SIZE];\n    snprintf(full_name, sizeof(full_name), \"%s/%s\", pdi_dir, filenames[i]);\n    // Use full_name safely\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<cstdio>`: For `snprintf`.\n- `<cstring>`: For string manipulation functions.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)\n\nThese links were verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-15a85280-7f2f-4f74-8476-3c18b568406a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe or deprecated due to their potential to cause security issues such as buffer overflows, format string vulnerabilities, or improper handling of input/output operations. The use of `fopen` is one such example, as it can lead to vulnerabilities if not handled correctly, especially when dealing with file paths and modes.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer, more modern alternatives provided by C++ standard libraries or third-party libraries that offer better security features.\n2. **Input Validation**: Always validate and sanitize inputs, especially file paths, to prevent directory traversal and other injection attacks.\n3. **Error Handling**: Implement robust error handling to manage unexpected conditions gracefully.\n4. **Least Privilege Principle**: Ensure that the application runs with the least privileges necessary to perform its tasks, reducing the impact of potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\nFor the specific vulnerability sink:\n\n```cpp\n#include <fstream>\n#include <iostream>\n#include <string>\n\nint main() {\n    std::string full_name = \"example.txt\";\n    std::ifstream file(full_name, std::ios::binary);\n\n    if (!file.is_open()) {\n        std::cerr << \"Error opening file: \" << full_name << std::endl;\n        return 1;\n    }\n\n    // Process the file\n    // ...\n\n    file.close();\n    return 0;\n}\n```\n\n### Library Dependencies\n\nThe above code example requires the following standard C++ library headers:\n\n- `<fstream>`: For file stream operations.\n- `<iostream>`: For standard input and output stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-6bdfabfd-e303-48d0-86bc-5c985cb3b3ec",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the C function `strlen` in C++ arises when the function is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited by attackers to execute arbitrary code or cause a denial of service.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input strings to ensure they are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions like `strnlen` which allows specifying a maximum length to prevent reading beyond the buffer.\n3. **Buffer Management**: Ensure that buffers are properly sized and null-terminated.\n4. **Static Analysis**: Use static analysis tools to detect potential vulnerabilities in code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability in the specific code snippet:\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <dirent.h>\n\nint main() {\n    DIR *dir;\n    struct dirent *ent;\n    if ((dir = opendir(\".\")) != NULL) {\n        while ((ent = readdir(dir)) != NULL) {\n            // Original vulnerable code\n            // len = strlen(ent->d_name);\n\n            // Fixed code using strnlen\n            size_t max_len = 256; // Define a reasonable maximum length\n            size_t len = strnlen(ent->d_name, max_len);\n            std::cout << \"Length of directory entry name: \" << len << std::endl;\n        }\n        closedir(dir);\n    } else {\n        perror(\"Could not open directory\");\n        return EXIT_FAILURE;\n    }\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following libraries are required:\n\n- `<cstring>`: For `strlen` and `strnlen` functions.\n- `<iostream>`: For input and output stream operations.\n- `<dirent.h>`: For directory operations.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-dc296706-ea33-441f-9152-34764edb4da2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ioctl_test.c"
                },
                "region": {
                  "startLine": 249,
                  "startColumn": 2,
                  "endLine": 249,
                  "endColumn": 9,
                  "charOffset": 5886,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-15a85280-7f2f-4f74-8476-3c18b568406a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ioctl_test.c"
                },
                "region": {
                  "startLine": 250,
                  "startColumn": 7,
                  "endLine": 250,
                  "endColumn": 12,
                  "charOffset": 5945,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6bdfabfd-e303-48d0-86bc-5c985cb3b3ec",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ioctl_test.c"
                },
                "region": {
                  "startLine": 223,
                  "startColumn": 12,
                  "endLine": 223,
                  "endColumn": 31,
                  "charOffset": 5288,
                  "charLength": 19,
                  "snippet": {
                    "text": "strlen(ent->d_name)",
                    "rendered": {
                      "text": "strlen(ent->d_name)",
                      "markdown": "`strlen(ent->d_name)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ioctl_test.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5288,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "strlen_s(ent->d_name, <size of ent->d_name>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ioctl_test.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5288,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "strnlen(ent->d_name, <size of ent->d_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}